---
title: "LÃ¶sung 2"
draft: true
---

# LÃ¶sung - Coding Basics (Einheiten 3 und 4)

Bei Bedarf finden sich hier nochmal die Slides zu Einheit 3:

::: {=html}
<iframe src="../01_slides/EH_3.html"
        width="100%"
        height="500"
        style="border:0; display:block; margin: 0 0 2rem 0;"></iframe>
:::

Und hier die Slides zu Einheit 4:

::: {=html}
<iframe src="../01_slides/EH_4.html"
        width="100%"
        height="500"
        style="border:0; display:block; margin: 0 0 2rem 0;"></iframe>
:::

# Lernziele dieses Hands-On-Blocks

âœ…Projekte

âœ…Unterschied zwischen relativen und absoluten Pfaden verstehen

âœ…DatensÃ¤tze in R importieren, inspizieren und speichern

âœ…DatensÃ¤tze mit `cbind()` und `full_join()` mergen und Vor- und Nachteile reflektieren

âœ…Funktionen und ihre Argumente (inkl. Defaults) nutzen

âœ…Style Conventions

# Projekte und Pfade

### Was sind R-Projekte?

ğŸ‘‰ [Kapitel 6.2 R4DS](https://r4ds.hadley.nz/workflow-scripts.html#projects)

Ein **R-Projekt** ist eine Projektdatei (`.Rproj`), die du in RStudio anlegst.\
Wenn du ein Projekt Ã¶ffnest:

-   RStudio setzt automatisch das **Working Directory (Arbeitsverzeichnis)** auf den Ordner, in dem `.Rproj` liegt.\
-   Alle Dateien, Skripte, Daten und Ergebnisse, die du in diesem Ordner ablegst, gehÃ¶ren logisch zu diesem Projekt.\
-   Man kann es sich vorstellen wie einen â€Containerâ€œ fÃ¼r ein Forschungsprojekt, eine Hausarbeit oder ein Analysepaket.\
-   Du kannst entweder ein neues Projekt erstellen oder ein bestehendes Projekt Ã¶ffnen.

ğŸ‘‰ In RStudio siehst du oben rechts, in welchem Projekt du dich gerade befindest. In diesem Screenshot ist noch kein Projekt geÃ¶ffnet.

![](../../images/EH3/Project.png)

**Ãœbung:**\
Im Ordner *Grinschgl2020* liegt bereits eine `.Rproj`-Datei. Ã–ffne sie und Ã¼berprÃ¼fe oben rechts in RStudio, ob du dich im richtigen Projekt befindest. Du kannst zukÃ¼nftig immer auf das Projekt klicken wenn du die Analyseskripte dazu Ã¶ffnen willst.

::: {.callout-note collapse="true" title="Bei Fehlermeldungen:"}
â€Achtung! Bei Mac-Usern kann es teilweise zu Problemen mit den Berechtigungen kommen. Falls dir beim Ã–ffnen diese Fehlermeldung angezeigt wird:â€œ

![](../../images/Hands%20on%202/Screenshot%202025-10-01%20at%2012.01.56.png)

Die LÃ¶sung besteht darin, die Berechtigungen fÃ¼r den Ordner anzupassen. DafÃ¼r gehst du auf den â€šr_you_readyâ€˜-Ordner und Ã¶ffnest das MenÃ¼ mit â€šGet Infoâ€˜.

![](../../images/Hands%20on%202/Screenshot%202025-10-01%20at%2013.10.23.png)

Die Berechtigungen passt du an, indem du auf das Schloss unten rechts klickst, dein Passwort eingibst und bei deinem Account â€šRead & Writeâ€˜ auswÃ¤hlst. Anschliessend klickst du auf die drei Punkte im Kreis und fÃ¼hrst â€šApply to enclosed itemsâ€¦â€˜ aus. Danach solltest du die vollen Berechtigungen haben.
:::

**Projekt erstellen**

Falls du in Zukunft ein Projekt erstellen willst (z.B. fÃ¼r deine Masterarbeit): ğŸ‘‰[Kapitel 6.2](https://r4ds.hadley.nz/workflow-scripts.html#projects)

------------------------------------------------------------------------

### Absolute vs. relative Pfade

-   **Absolute Pfade** beschreiben den vollstÃ¤ndigen Weg zu einer Datei, ausgehend vom Wurzelverzeichnis *deines* Computers.

    ğŸ”´ Nachteil: Sie sind oft sehr lang und funktionieren nur auf deinem Rechner.\

    -   Beispiel (Windows):\
        `C:\Users\maxmustermann\Dokumente\r_you_ready\Grinschgl2020\data\raw\Beispieldatei.csv`

-   **Relative Pfade** beschreiben den Ort einer Datei relativ zum *aktuellen Arbeitsverzeichnis*.

    ğŸŸ¢ Vorteil: Sie sind kÃ¼rzer und funktionieren auf jedem Rechner, solange die Projektstruktur gleich bleibt.\

    -   Beispiel:

        -   Projektordner = *Grinschgl2020*
        -   Datei liegt in *data/raw/Beispieldatei.csv*
        -   relativer Pfad:

        ```         
        data/raw/Beispieldatei.csv
        ```

**â“Beantworte fÃ¼r dich selbst:**

Um ein Skript reproduzierbar zu gestalten â€“ was eignet sich besser: relative Pfade oder absolute Pfade? Aus welchen GrÃ¼nden?

::: {.callout-note collapse="true" title="LÃ¶sung"}
Ãœblicherweise eignen sich relative Pfade besser als absolute Pfade, da diese unabhÃ¤ngig vom Computer funktionieren, auf dem das Skript ausgefÃ¼hrt wird. Dabei muss allerdings darauf geachtet werden die Projektstruktur gleich zu halten - deshalb empfiehlt es sich allgemeinen Standards wie dem PsychDS zu folgen.
:::

# Daten importieren und exportieren

## Import

ğŸ‘‰ [Kapitel 3.2](https://methodenlehre.github.io/einfuehrung-in-R/chapters/03-data_frames.html#daten-importieren)

[Cheatsheat Datenimport](https://rstudio.github.io/cheatsheets/html/data-import.html) mit `readr`

### Einlesen via OberflÃ¤che

-   Stelle sicher, dass du das Metapaket **tidyverse** geladen hast (`library(tidyverse)`) (siehe Hands-On 1).\
    Wir verwenden Funktionen aus den Packages **readr** und **readxl**, die Teil des Tidyverse sind.

In diesem Seminar arbeiten wir mit csv und xslx Dateien. Wie werden uns mehere Arten und Weisen anschauen wie man diese einlesen kann.

Beim Einlesen von Daten ist ein wichtiger Faktor, mich welchem Trennzeichen (Delimiter) die Werte von einander getrennt werden.

Auszug aus [Cheatsheet](https://rstudio.github.io/cheatsheets/html/data-import.html): Die Funktionen read_delim und read_csv:

![](../../images/cheat.png)

`read_csv()` ist eine Spezialisierung von `read_delim()`, die automatisch Komma als Trennzeichen verwendet, wÃ¤hrend man bei `read_delim()` das gewÃ¼nschte Trennzeichen selbst angeben muss.

-   Importiere die Datei `"data_mmq.csv"` Ã¼ber die Point & Klick-OberflÃ¤che von RStudio. Verwende dafÃ¼r "From Text (readr)"

![](../../images/import.png)

    -   Tipp: Klicke auf **Environment** â†’ **Import Dataset** â†’ wÃ¤hle die `"readr"`-Funktion.
    -   Schaue dir den Datensatz an: Mit welchem Trennzeichen sind die Daten getrennt?

::: {.callout-note collapse="true" title="Vertiefung"}
Ohne eine Anpassung des Trennzeichens wird als Default das Komma "," verwendet. Dies liegt am Ã¼blichen Trennzeichen des Dateityps des Datensatzes, csv (comma-separated values). In unserem Fall sind die Daten jedoch mit einem Semikolon ";" getrennt. Deswegen werden im vorliegenden Fall die Daten in dem Vorschaufenster in einer einzigen Spalte eingelesen und nicht sauber getrennt.
:::

```         
-   ![](../../images/clipboard-4280669528.png)
    -   Stelle in der OberflÃ¤che `"Delimiter"` auf das passende Trennzeichen. Was verÃ¤ndert sich?
```

::: {.callout-note collapse="true" title="LÃ¶sung"}
Das passende Trennzeichen ist in unserem Fall das Semikollon ";". Wenn auf dieses Trennzeichen gewechselt wird, dann werden die Daten in der Ansicht sauber in einzelne Spalten getrennt und die Daten kÃ¶nnen passend eingelesen werden.
:::

```         
-   Betrachte den Code, den die OberflÃ¤che generiert. Versuche den Pfad im Kontext von Projekten zu verstehen.
    -   Wenn du im Projekt gearbeitet hast, sollte bei dir der Code etwa so aussehen: `data_mmq <- read_delim("data/raw/data_mmq.csv", delim = ";", escape_double = FALSE, trim_ws = TRUE)`
    -   Wenn du nicht im Projekt gearbeite hÃ¤ttest, wie wÃ¼rde dann der Dateipfad aussehen?
```

::: {.callout-note collapse="true" title="LÃ¶sung"}
Der Dateipfad kÃ¶nnte dann etwa so aussehen:

"data/raw/data_mmq.csv"

Relevant ist vor allem, dass ein absoluter Dateipfad verwendet wird, der in dieser Form auf dem eigenen Computer funktioniert. Das Einlesen der Daten wÃ¤re somit fÃ¼r andere Personen nicht ohne Anpassungen replizierbar. Deswegen achtet darauf beim Einlesen der Datei relative Pfade zu verwenden!
:::

```         
-   Wenn du den Code via Klick-OberflÃ¤che eingelesen hast, wirst du den ausgefÃ¼hrten Code in der Konsole sehen. Kopiere diesen in dein Skript, so dass du ihn in Zukunft wiederverwenden und anpassen kannst.
-   Schaue dir die eingelesenen Daten mit `View(data_mmq)` an. Wenn du alles richtig gemacht hast, ist in jeder Zelle nur ein Wert.
```

### Einlesen via Code

#### .CSV Dateien

-   Versuche, weitere CSV-DatensÃ¤tze einzulesen: `data_cb`, `data_cvstm`, `data_pct`, `data_vp`.\
    Suche dafÃ¼r eine geeignete Funktion zum Einlesen von `.csv`.

::: {.callout-note collapse="true" title="LÃ¶sung"}
Die Funktion `read_csv()` aus dem Paket `readr` ist eine geeignete Funktion zum Einlesen von .csv Dateien. Diese Funktion verwendet automatisch das Komma als Trennzeichen.

```{r}
# install.packages("readr") # den Code fÃ¼hrst du einmalig in deiner Console aus
# wenn du schon das Tidyverse geladen hast, musst du readr nicht extra laden - dieses ist in Tidyverse beinhaltet 
library(readr)

data_cb <- read_delim("data/raw/data_cb.csv", delim = ";")
data_cvstm <- read_delim("data/raw/data_cvstm.csv", delim = ";")

data_pct <- read_delim("data/raw/data_pct.csv", ";")

data_vp <- read_delim("data/raw/data_vp.csv" , ";")
```

Wie in der Aufgabenstellung bereits beschrieben verwendet `read_csv()` automatisch das Komma als Trennzeichen. Daher werden die DatensÃ¤tze hier zwar eingelesen, sind dann allerdings nicht korrekt formatiert. Wenn die Daten mit einem anderen Trennzeichen getrennt sind, muss eine andere Funktion verwendet werden, z.B. `read_delim()`, bei der das Trennzeichen explizit angegeben werden muss.

```{r}
F
```
:::

```         
-   Verwende den von R-Studio generierten Code, und passe ihn an um einen weiteren Datensatz einzulesen (z.B. indem du den Filenamen verÃ¤nderst).
```

::: {.callout-note collapse="true" title="LÃ¶sung"}
```{r}
data_mmq <- read_delim("data/raw/data_mmq.csv",
                      delim = ";")
```
:::

-   Korrigiere diesen Code und lies damit die Datei `data_vp` ein (Ã¼berprÃ¼fe den Pfad und den Delimiter)

```{r}
# data_vp <- read_delim("/raw/data_vp.csv", 
#     delim = ",")
```

::: {.callout-note collapse="true" title="LÃ¶sung"}
```{r, eval=FALSE, echo=TRUE}
# Was wir dir vorgegeben hatten:
# data_vp <- read_delim("/raw/data_vp.csv", 
#    delim = ",")

# Korrigierter Code:
data_vp <- read_delim("data/raw/data_vp.csv",
                      delim = ";")
```
:::

#### .XSLX Dateien

-   Einige Dateien liegen im `.xlsx`-Format.

    -   Verwende dafÃ¼r das Paket **readxl** und die Funktion `read_excel()`. Tipp: Installiere und lade das Paket zunÃ¤chst.
    -   Nutze die Hilfefunktion (`?read_excel`) fÃ¼r Infos zur Funktion oder schaue dir das [Cheatsheet](https://rstudio.github.io/cheatsheets/html/data-import.html) an
    -   Versuche, die DatensÃ¤tze `data_ratings` und `data_strategies` einzulesen.

::: {.callout-note collapse="true" title="LÃ¶sung"}
```{r}
# install.packages("readxl") # den Code fÃ¼hrst du einmalig in deiner Console aus
library(readxl)

?read_excel() # Aufruf der Dokumentation

data_ratings <- read_excel("data/raw/data_ratings.xlsx") # erstellt Ã¼ber RStudio Environment

data_strategies <- read_excel("data/raw/data_strategies.xlsx") # kopiert und angepasst
```
:::

-   Am Ende solltest du die **7 verschiedene DatensÃ¤tze** in deinem Environment sehen.

::: {.callout-note collapse="true" title="Vertiefung"}
ğŸ‘‰FÃ¼r das Einlesen anderer Arten von DatensÃ¤tzen (z.B. SPSS Dateien), siehe [Kapitel 3.2](https://methodenlehre.github.io/einfuehrung-in-R/chapters/03-data_frames.html#daten-importieren)
:::

# Daten mergen

***Wird in EH4 noch genauer erklÃ¤rt - aber probiere auch gerne schon vorab!***

Nun haben wir 7 verschiedene DatensÃ¤tze in unserem Enviornment. Da wir jedoch mit dem kompletten Datensatz arbeiten wollen, ist es sinnvoll diese DatensÃ¤tze zu einem zu verbinden. Jedoch mÃ¼ssen dafÃ¼r mehrere Dinge beachtet werden: Sind die Daten in der gleichen Reihenfolge (z.B. geordnet nach Identifier (z.B. `code` in `data_mmq`).

**MÃ¶gliche Funktionen:** z. B. `cbind()` aus Base R oder `full_join()` aus dem Tidyverse.

## Aufgaben

### FÃ¼ge alle 7 DatensÃ¤tze mit `cbind()` zusammen und schaue dir das Ergebnis an.

::: {.callout-note collapse="true" title="LÃ¶sung"}
```{r}
dat_cbind <- cbind(data_mmq, data_cb, data_cvstm, data_pct, data_vp, data_ratings, data_strategies)
```
:::

-   Was fÃ¤llt dir auf?\
-   Hinweis: Die DatensÃ¤tze werden einfach nebeneinander â€geklebtâ€œ, ohne inhaltlich abgeglichen zu werden.\
-   Reflektiere: Macht das Sinn? Was sind die Gefahren, Daten auf diese Art zu mergen?

::: {.callout-note collapse="true" title="LÃ¶sung"}
Sinn ergibt das einfache "kleben" Ã¼ber cbind nicht. Nur fÃ¼r den Fall das alle DatensÃ¤tze in der entsprechenden Zeile dieselbe Versuchsperson abdecken wÃ¤re das einfache zusammenkleben Ã¼berhaupt zulÃ¤ssig. Andernfalls wÃ¼rden EintrÃ¤ge von Versuchspersonen vermischt werden.
:::

------------------------------------------------------------------------

### Versuche es nun mit `full_join()`.

Full_join verbindet zwei DatensÃ¤tze anhand einer SchlÃ¼sselvariable, so dass alle Zeilen aus beiden DatensÃ¤tzen erhalten bleiben. Die SchlÃ¼sselvariable ist essentiell dafÃ¼r dass die DatensÃ¤tze richtig verbunden werden (Anordnung der Variablen), und grenzt sich dadurch von Funktionen wie `cbind()` ab.

![](../../images/join.gif){width="307"}

-   Lege eine gemeinsame Variable als SchlÃ¼ssel fest, hier: `by = "code"`.

-   FÃ¼ge nun alle 7 DatensÃ¤tze zu einem zusammen, nenne diesen `dat_full`

    -   **Achtung:** `full_join()` funktioniert immer nur mit 2 DatensÃ¤tzen gleichzeitig ğŸ‘‰ du musst es also mehrfach anwenden, um alle 7 DatensÃ¤tze zusammenzufÃ¼hren.

    -   Hinweis: Im Datensatz `data_pct` heiÃŸt die Code-Variable leicht anders. Verwende deshalb `by = c("code_all" = "code")`.

::: {.callout-note collapse="true" title="LÃ¶sung"}
```{r}
library(tidyverse)

# Hier werden zu Beginn die beiden DatensÃ¤tze data_mmq und data_cb zusammengefÃ¼gt und in dat_step_1 gespeichert (Ã¼ber `code` wird sichergestellt, dass die passenden Zeilen hintereinander stehen)
dat_step_1 <- full_join(data_mmq, data_cb, by = "code")

# Hier wird data_cvstm an dat_step_1 angefÃ¼gt und in dat_step_2 gespeichert.
dat_step_2 <- full_join(dat_step_1, data_cvstm, by = "code")

# ...
dat_step_3 <- full_join(dat_step_2, data_pct, by = c("code" = "code_all"))

dat_step_4 <- full_join(dat_step_3, data_vp, by = "code")

dat_step_5 <- full_join(dat_step_4, data_ratings, by = "code")

dat_full <- full_join(dat_step_5, data_strategies, by = "code")

# Eine alternative Schreibweise (welche die Pipe verwendet, die wir erst noch nÃ¤her kennenlernen werden):

dat_full <- data_mmq %>%
  full_join(data_cb, by = "code") %>%
  full_join(data_cvstm, by = "code") %>%
  full_join(data_pct, by = c("code" = "code_all")) %>%
  full_join(data_vp, by = "code") %>%
  full_join(data_ratings, by = "code") %>%
  full_join(data_strategies, by = "code")
```
:::

------------------------------------------------------------------------

### Inspiziere deinen zusammengefÃ¼gten Datensatz "dat_full"

-   ğŸ”ÃœberprÃ¼fe: Wie viele Zeilen und Spalten hat dein Datensatz? Verwende: `ncol()` , `nrow()`, `dim()`
    -   Stimmt die Anzahl der Zeilen mit der Anzahl der Versuchspersonen aus dem Paper Ã¼berein?

::: {.callout-note collapse="true" title="LÃ¶sung"}
```{r}
ncol(dat_full) # Anzahl der Spalten
nrow(dat_full) # Anzahl der Zeilen
dim(dat_full)  # Anzahl der Zeilen und Spalten
```

Der vollstÃ¤ndige Datensatz enthÃ¤lt Informationen von 159 Versuchspersonen. Das entspricht der Angabe aus dem Paper von Grinschgl et al., 2020.
:::

-   ğŸ‘€Verschaffe dir eine Ãœberblick Ã¼ber deinen Datensatz mit den Funktionen, die wir schon im letzten Hands On getestet haben:
    -   Lasse dir die Variablenamen ausgeben mit `names()`
    -   `head()`
    -   `glimpse()`
    -   `str()`
    -   `dat_full`
    -   `summary()`
-   Gibt es redundante oder doppelte Variablen?

::: {.callout-note collapse="true" title="LÃ¶sung"}
```{r}
names(dat_full)
head(dat_full)
glimpse(dat_full)
str(dat_full)
dat_full
summary(dat_full)
```

Es gibt keine redundanten oder doppelten Variablen.
:::

**Auf einzelne Werte zugreiffen:**

-   Greife auf den **ersten Wert der ersten Spalte** zu: Verwende eckige Klammern. Der erste Wert in der Klammer steht fÃ¼r die Zeile, der zweite fÃ¼r die Spalte.

::: {.callout-note collapse="true" title="LÃ¶sung"}
```{r}
dat_full[1, 1]
```
:::

-   Greife auf die Werte der **Spalten 1â€“15 in der ersten Zeile** zu. Verwende wieder eckige Klammern und den Bereichsoperator `1:15`.

::: {.callout-note collapse="true" title="LÃ¶sung"}
```{r}
dat_full[1, 1:15]
```
:::

-   Lasse dir alle Werte der Variable `"mean_rl_all"` ausgeben. Auf Variablen greifst du mit `$` zu.

::: {.callout-note collapse="true" title="LÃ¶sung"}
```{r}
dat_full$mean_rl_all
```
:::

-   Greife auf die **ersten 10 Werte der Variable `"question1"`** zu. Verwende dazu den `$`-Operator in Kombination mit dem Bereichsoperator `1:10`.

::: {.callout-note collapse="true" title="LÃ¶sung"}
```{r}
dat_full$question1[1:10]
```
:::

------------------------------------------------------------------------

# Daten speichern

### Speichere `dat_full` in deinem Ordner `"data"` als CSV-Datei ab

Verwende dafÃ¼r die Funktion `write.csv()`. Du musst zwei Argumente angeben: Welcher Datensatz aus deinem Environment gespeichert werden soll und unter welchem Pfad (inklusive Dateiname) er abgelegt wird. Bei Unklarheiten schaue dir das [Cheatsheet](https://rstudio.github.io/cheatsheets/html/data-import.html) oder die Hilfefunktion an. ÃœberprÃ¼fe nach dem speichern, ob dein Datensatz im richtigen Ordner zu finden ist.

::: {.callout-note collapse="true" title="LÃ¶sung"}
```{r}
write.csv(dat_full, "data/processed/dat_full.csv", row.names = FALSE)
```
:::

ğŸ‘‰ FÃ¼r diesen Datensatz sollt ihr anschlieÃŸend das **Codebook** erstellen.

------------------------------------------------------------------------

# Coding Basics: Funktionen

ğŸ‘‰[Kapitel 2.4: Calling Functions](https://r4ds.hadley.nz/workflow-basics.html)

ğŸ‘‰[Kapitel 2.3: Funktionen aufrufen](https://methodenlehre.github.io/einfuehrung-in-R/chapters/02-R-language.html#funktionen-aufrufen)

Wir haben in diesen Ãœbungen bereits einige Funktionen verwendet (z. B. `sum()` oder `sort()`). Funktionen bestehen aus einem Namen und Argumenten. In diesem Beispiel wird die Funktion `sort()` aufgerufen. Die Argumente, die dafÃ¼r benÃ¶tigt werden, sind `first_vector` und `decreasing = TRUE`. Die meisten Funktionen haben *Defaults*, also Argumente mit einer Voreinstellung. Wenn man diese nicht verÃ¤ndern mÃ¶chte, mÃ¼ssen sie nicht explizit angegeben werden. `sort()` hat als Default `decreasing = FALSE`. Deswegen mÃ¼ssen wir, um die hÃ¶chsten Werte des Vektors zu bestimmen, diesen Default umstellen. Argumente ohne Defaults mÃ¼ssen zwingend angegben werden).

Die Defaults von Funktionen lassen sich Ã¼ber die Hilfefunktion nachschauen. Diese kann entweder im Tab *Help* geÃ¶ffnet werden oder direkt Ã¼ber die Konsole mit `?Funktionsname`.

```{r}
first_vector <- c(22342, 4, 5, 6, 7, 23234, 342, 342)
highest_values_1 <- sort(first_vector)[1:2]
highest_values <- sort(first_vector, decreasing = TRUE)[1:2]
```

Bei vielen Funktionen werden die **Namen der Argumente** weggelassen.

Welche Argumente werden hier Ã¼bergeben? Schreibe die Funktion mit den vollstÃ¤ndigen Argumentnamen aus:

```{r}
 seq(-4, 11, 3)
```

::: {.callout-note collapse="true" title="LÃ¶sung"}
```{r}
?sort() # Aufruf der Dokumentation um die Argumente, ihre Reihenfolge und ggf. auch ihre Defaults zu sehen

seq(from = -4, to = 11, by = 3)
```
:::

Wenn die Argumente nicht explizit benannt werden, ist die Reihenfolge entscheidend. Wenn du die Argumente explizit angibst, kannst du die Reihenfolge frei wÃ¤hlen.

-   Korrigiere diesen Code: ErgÃ¤nze die Argumentnamen, sodass eine Sequenz von 3 bis 12 in 2er-Schritten erstellt wird. Belasse dabei die Reihenfolge der Zahlen.

```{r, eval=FALSE, echo=TRUE}
seq(2, 12, 3)
```

::: {.callout-note collapse="true" title="LÃ¶sung"}
```{r, eval=TRUE, echo=TRUE}
seq(by = 2, to =  12, from = 3)
```
:::

â„¹ï¸Manche Funktionen sind in mehreren Paketen beinhaltet, sowie wie z.B. die Funktion `filter()`. Um die Funktion definitiv aus einem bestimmten Paket zu verwenden, muss man das Paket dazu schreiben: `dyplr::filter()`

## Tab Completion:

Eine nÃ¼tzliche Funktion von RStudio ist die **Tab Completion**. Wenn du eine Funktion aufrufst und die Tabulator-Taste drÃ¼ckst, erscheint ein MenÃ¼ mit den mÃ¶glichen Argumenten, die du angeben kannst. Probiere es mit der Funktion `mean()`. Das funktioniert auch fÃ¼r Funktionen aus Paketen, wenn du diese mit `::` auswÃ¤hlst, zum Beispiel: `readr::`.

::: {.callout-note collapse="true" title="Anmerkung"}
```{r}
# readr::

# mean(

# Die LÃ¶sung hierzu kann ich euch nicht darstellen, da es sich um ein Feature von RStudio handelt, welches nur "live" angezeigt wird. Ihr kÃ¶nnt aber den hier auskommentierten Code verwenden und es damit ausprobieren
```
:::

## Weitere Tasten und TastenkÃ¼rzel:

ğŸ‘‰[Kapitel 1.4.6](https://methodenlehre.github.io/einfuehrung-in-R/chapters/01-workflow.html#tasten)

In RStudio benÃ¶tigen wir hÃ¤ufig Zeichen, die wir im Alltag kaum verwenden. Da wir nicht alle mit dem gleichen Betriebssystem (Mac/Windows) und auch nicht mit identischen Tastaturen arbeiten, kÃ¶nnen wir keine einheitlichen Angaben machen, wo sich diese Zeichen genau befinden. Versuche daher, die folgenden Zeichen auf deiner eigenen Tastatur zu finden:

-   `[ ]` Square brackets (eckige Klammern)

-   `{ }` Curly brackets (geschweifte Klammern)

-   `$` Dollar sign (Dollarzeichen â€“ wird fÃ¼r das AuswÃ¤hlen von Variablen benÃ¶tigt)

-   `#` Hash (Rautezeichen â€“ fÃ¼r Kommentare in R-Skripten)

-   `~` Tilde (fÃ¼r Modellnotationen in R; brauchen wir v.a. am Ende des Semesters bei den Analysen)

-   `|` Vertical bar (senkrechter Strich â€“ als logischer Operator)

-   `` ` `` Backtick (Gravis â€“ vor allem fÃ¼r Code Chunks, selten manuell einzugeben)

## Verschachtelte Funktionen:

â„¹ï¸Es ist zwar mÃ¶glich, mehrere Funktionen ineinander zu verschachteln. Dies kann jedoch schnell zu Verwirrung fÃ¼hren und den Code unnÃ¶tig unÃ¼bersichtlich machen. Verschachtelte Funktionen werden von innen nach aussen ausgefÃ¼hrt.

â“Stelle dir hier die Frage: Was wird genau gerundet? Die einzelnen Elemente des Vektors oder der errechnete Durchschnitt?

```{r}
print(mean(round(first_vector)))
```

â—Aufgabe: Zerlege die Verschatelte Funktion in ihre Teilschritte.

::: {.callout-note collapse="true" title="LÃ¶sung"}
```{r}
rounded_values <- round(first_vector)
mittelwert <- mean(rounded_values)
print(mittelwert)
```
:::

# Style Conventions

Korrigiere diesen Code so dass er

-   Fehlerfrei lÃ¤uft

-   Leserlicher ist: Beachte dafÃ¼r

    -   Naming Conventions

    -   Weitere Style Vorgaben (z.B. Leerzeichen)

```{r, eval=FALSE, echo=TRUE}

FranzÃ¶sischschul_NotenSemesester -<(4,5, 6,5,4,  3)
mean <-mean(FranzÃ¶sichschul_NotenSemsester
print  ( mittelwert)

```

::: {.callout-note collapse="true" title="LÃ¶sung"}
```{r}
# Vorgegeben:
# FranzÃ¶sischschul_NotenSemesester -<(4,5, 6,5,4,  3)
# mean <-mean(FranzÃ¶sichschul_NotenSemsester
# print  ( mittelwert)

# Angepasst:
franzoesischschul_notensemester <- c(4.5, 6.5, 4, 3)
mean <- mean(franzoesischschul_notensemester)
print(mean)
```
:::

-   Installiere das Package `styler` mit `install.packages()` und lade es. `styler` hat eine sogenannte "Wrapper-Funktion", die du unter "Addins" aufrufen kannst (evtl. musst du R vor dem Laden neu starten). Verwende den Default-Style (tidyverse).

::: {.callout-note collapse="true" title="LÃ¶sung"}
```{r}
# install.packages("styler") # den Code fÃ¼hrst du einmalig in deiner Console aus
library(styler)
```
:::

![](../../images/styler.png)
-   Versuche mit der `Styler` -Funktion diesen Code zu leserlicher zu machen (markiere den Code und wÃ¤hle *Style selection*). (Du musst diesen ggplot Code nicht verstehen - wir kommen dazu in einer spÃ¤teren Einheit noch.)

```{r, eval=FALSE}
library(ggplot2)
library(palmerpenguins)

ggplot(penguins,aes(x=flipper_length_mm,y=body_mass_g,color=species))+geom_point()+labs(x="flipper",Y="MASS")+theme_minimal()

```

::: {.callout-note collapse="true" title="LÃ¶sung"}
```{r}
library(ggplot2)
library(palmerpenguins)
ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +
  geom_point() +
  labs(x = "flipper", Y = "MASS") +
  theme_minimal()
```
:::

# Am Ende deiner Ãœbungen - vergiss nicht dein Skript abzuspeichern! :-)
