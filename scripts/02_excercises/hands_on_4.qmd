---
title: "Hands On ‚Äì Tidy (Einheiten 7 und 8)"
editor: visual
bibliography: references.bib
---

```{r, echo = FALSE, results = 'hide', message= FALSE}
library(tidyverse)
library(readr)

dat_full <- read_csv("raw/dat_full.csv")
```

Bei Bedarf finden sich hier nochmal die Slides zur EH7:

::: {=html}
<iframe src="../01_slides/EH_7.html" width="100%" height="500" style="border:0; display:block; margin: 0 0 2rem 0;">

</iframe>
:::

Und hier die Slides zur EH8:

::: {=html}
<iframe src="../01_slides/EH_8.html" width="100%" height="500" style="border:0; display:block; margin: 0 0 2rem 0;">

</iframe>
:::

# Lernziele

‚úÖ Pipe-Operator \|\> oder %\>% kennenlernen und anwenden

‚úÖ dplyr-Funktionen verstehen und nutzen

‚úÖ Skalenberechnung & Kodierung

‚úÖ Identifikation und Umgang mit fehlenden Werten

# **Pipe-Operator**

[üìñKapitel 4.2 Ellis & Mayer](https://methodenlehre.github.io/einfuehrung-in-R/chapters/04-tidyverse.html#der-pipe-operator)

::: callout-tip
**Tastenkombinationen f√ºr den Pipe Operator:**

**Windows/Linux:** `Ctrl` + `Shift` + `M` ‚Üí f√ºgt \|\> ein

**Mac:** `Cmd` + `Shift` + `M` ‚Üí f√ºgt \|\> ein

Vergiss nicht, dass du das `tidyverse` laden musst um die Pipe zu verwenden!

Ggf. musst du unter "Tools" - "Global Options" - "Code" noch den "Native Pipe Operator" aktivieren
:::

**Aufgabe:**

Schreibe folgenden Code mit der Pipe um:

```{r}
mean(round((seq(1:20)), digits = 2), trim = 0.5) 
```

üí° Hinweis: √úberlege, welche Schritte nacheinander ausgef√ºhrt werden und wie man sie mit \|\> lesbarer machen kann.

::: callout-tip
Versuche in den folgenden √úbungen wenn m√∂glich mit der Pipe zu arbeiten!
:::

# Datenaufbereitung ‚Äì Tidy & Transform

In den folgenden Aufgaben lernen wir die grundlegenden Funktionen des **dplyr**-Packages aus dem **tidyverse** kennen.

**Hier findest du ein Cheatsheet zu den dplyr-Funktionen:**

<iframe src="../../PDFs/dplyr_cheatsheet.pdf" width="100%" height="600px">

</iframe>

## filter()

### **√úbungen zu `filter()`**

Diese Aufgaben helfen dir, den Umgang mit `dplyr`-Funktionen wie `filter()` und `select()` zu √ºben.

Der Datensatz hei√üt **`dat_full`** und enth√§lt 159 Zeilen und 36 Variablen. Stelle sicher, dass du diesen geladen hast.

*Reminder: Verwende die logischen Operatoren, die wir in Hands On 1 kennengelernt haben.*

| Zeichen | Bedeutung      |
|---------|----------------|
| ==      | gleich         |
| !=      | ungleich       |
| \>      | gr√∂sser        |
| \>=     | gr√∂sser gleich |
| \<      | kleiner        |
| \<=     | kleiner gleich |
| \|      | Logisches Oder |
| &       | Logisches Und  |

-   **Erste Schritte mit Filter**

    -   W√§hle alle Teilnehmenden aus, die in der Gruppe `"above"` sind.

    -   W√§hle alle Teilnehmenden aus, die mehr als 0.7 in `cvstm_propcorrect` erreicht haben.

```{r, echo = FALSE, results = 'hide'}

dat_full_filtered_above <- dat_full |>  
  filter(group_all == "above")

dat_full_filtered_cvstm_07 <- dat_full |>  
  filter(cvstm_propcorrect > 0.7)
```

-   **Kombinierte Filter: Nutze die Pipe um beide Filter nacheinander auszuf√ºhren.**

    -   Filtere alle, die gleichzeitig in der Gruppe `below` sind UND weniger als 0.6 in `vp_propcorrect` haben.

    -   W√§hle alle F√§lle aus, deren `strategies` gr√∂√üer oder gleich 2 sind oder deren Wert in `mean_rl_all` nicht gleich 4.5 ist.

```{r, echo = FALSE, results = 'hide'}
dat_full_combined_filters <- dat_full |>  
  filter(group_all == "below", vp_propcorrect < 0.6) |>  
  filter(strategies >= 2 | mean_rl_all != 4.5)
```

## select()

### **√úbungen zu select()**

a)  W√§hle die Variablen (bzw. Spalten) `code`, `group_all`, `vp_sum` und `cvstm_propcorrect` aus `dat_full` aus

```{r, echo = FALSE, results = 'hide'}
select(dat_full, c(code, group_all, vp_sum, cvstm_propcorrect))
```

### **Kombination von filter() und select()**

a)  W√§hle alle Personen aus der Gruppe "above" aus, die mehr als 0.8 in `vp_propcorrect` haben,

    und zeige nur `code`, `group_all`, `vp_sum`, `vp_propcorrect` an.

```{r, echo = FALSE, results = 'hide'}

dat_full |>  
  filter(group_all == "above", vp_propcorrect > 0.8) |>  
  select(code, group_all, vp_sum, vp_propcorrect)

```

## rename()

-   Benenne die Variable `group_all` in `group` um, indem du die Funktion `rename()` verwendest; achte dabei darauf, dass der neue Name zuerst angegeben wird.

    Anmerkung: je nachdem wie du deine Daten gemerged hast, heisst die Variable bereits "group". Dann ist dieser Schritt nicht notwendig.

```{r, echo = FALSE, results = 'hide'}
dat_full <- rename(dat_full, group = group_all)
```

## mutate()

Nur f√ºr √úbungszwecke: Erstelle eine neue Spalte aus der Variable `group`. Aus `above` soll `EG1`, aus `below` `EG2` und aus `control` `KG` werden. Verwende daf√ºr eine Kombination aus `case_when()` (oder `recode()`) und `mutate()`

```{r, echo = FALSE, results = 'hide'}
dat_full |> 
  mutate(
    group_new = case_when(
      group == "above"   ~ "EG1",
      group == "below"   ~ "EG2",
      group == "control" ~ "KG"
    )
  )

# oder alternativ mit recode()
dat_full |>
  mutate(
    group_new = recode(
      group,
      "above"   = "EG1",
      "below"   = "EG2",
      "control" = "KG"
    )
  )
```

## summarize()

Dich interessieren der **Durchschnitt (mean)** und die **Standardabweichung (sd)** der Variable `mean_e1_all`. Du m√∂chtest diese Werte jedoch **nicht** zu `dat_full` hinzuf√ºgen, sondern als **Zusammenfassung in einem neuen Objekt** speichern.\
Nutze daf√ºr die Funktion `summarize()`.

```{r, echo = FALSE, results = 'hide'}

summary_e1_all <- dat_full |>
  summarize(
    mean_e1 = mean(mean_e1_all, na.rm = TRUE),
    sd_e1   = sd(mean_e1_all, na.rm = TRUE)
  )

summary_e1_all
```

## Kombination summarize() und group_by()

Finde heraus, wie die **durchschnittlichen Werte** und **Standardabweichungen** von `pre4` in den verschiedenen Gruppen (`group`) ausfallen.

-   Nutze daf√ºr zuerst `group_by()`

-   Pipe das Ergebnis in `summarize()`

```{r, echo = FALSE, results = 'hide'}

dat_full |>
  group_by(group) |>
  summarise(
    mean_pre4 = mean(pre4),
    sd_pre4   = sd(pre4)
  )
```

So kannst du zum Beispiel Tabelle 1 aus Grinschgl et al. (2020) reproduzieren.

## Anwendung: dplyr-Funktionen

In der Analyse von Grinschgl et al. (2020), werden die Skalenwerte des MMQ-Fragebogens untersucht.\
Um diese auszuwerten, m√ºssen wir den Skalenwert pro Person berechnen.

### Berechnen von *mmq_mean*

Mit `mutate()` kannst du einem bestehenden Datensatz eine neue Spalte hinzuf√ºgen.\
Um die Daten des MMQ zu analysieren, f√ºge eine Spalte hinzu, die den Durchschnitt (*mmq_mean*) √ºber alle 18 Items (z. B. `question1` bis `question18`) enth√§lt.

üí° **Tipps:**

-   Verwende `rowMeans()` statt `mean()`, um den Mittelwert pro Versuchsperson zeihlenweise zu berechnen.

-   Du kannst mit `starts_with()` alle Spalten ausw√§hlen, die mit *question* beginnen.

-   Wenn die Items im Datensatz nebeneinanderstehen, kannst du sie auch mit einem Bereich ausw√§hlen, z. B. `question1:question18`.

## Multiplizieren von Pre Ratings

Die Variablen *pre1*‚Äì*pre4* und *post* stellen in der Studie die Leistungseinsch√§tzungen auf einer Skala von 1 bis 100 dar. In unserem Datensatz sind sie jedoch nur auf einer Skala von 1 bis 10 abgebildet. Verwende die Funktion `mutate`, um die Variablen mit 10 zu multiplizieren und so die richtigen Werte zu erhalten.

```{r, echo = FALSE, results = 'hide'}
dat_full <- dat_full %>%
  mutate(
    pre1 = pre1 * 10,
    pre2 = pre2 * 10,
    pre3 = pre3 * 10,
    pre4 = pre4 * 10,
    post = post * 10
  )

```

Weitere Informationen zu dplyr findest du auch hier: [üìñKapitel 4.4 Ellis & Mayer](https://methodenlehre.github.io/einfuehrung-in-R/chapters/04-tidyverse.html#data-wrangling-dplyr)

# Fehlende Werte

In den meisten Datens√§tzen gibt es **fehlende Werte**.\
Diese k√∂nnen je nach verwendeter Software **unterschiedlich kodiert** sein.

## **H√§ufige Formen fehlender Werte**

-   `NA` (R-typische Kennzeichnung f√ºr *Not Available*)

-   `999` oder `-999` (h√§ufig manuell gesetzte Platzhalter)

-   leere Zellen (`""`)

-   `NULL` (in manchen Programmiersprachen, aber in R selten in Datens√§tzen verwendet)

## Umgang mit fehlenden Werten

Im Umgang mit fehlenden Werten sollten wir:

1.  **Pr√ºfen**, ob und wie viele Werte fehlen.

2.  **Verstehen**, warum sie fehlen (z. B. fehlende Eingabe durch Teilnehmende).

3.  **Entscheiden**, wie mit den fehlenden Werten umgegangen werden soll ‚Äì basierend auf dieser Analyse.

## Aufgabe:

```{r}
#| label: download-bfi-data
#| echo: false
#| message: false
#| warning: false
#| results: "hide"

# Copy the dataset file to make it downloadable

file.copy(
  "raw/bfi_10_data.csv",
  "bfi_10_data.csv",
  overwrite = TRUE
)

bfi_10_data <- readr::read_csv(
  "raw/bfi_10_data.csv"
)
```

<a href="bfi_10_data.csv" download class="btn btn-primary"> üì• Download bfi_10_data.csv </a>

[üìñKapitel 4.3.3 Ellis & Mayer](https://methodenlehre.github.io/einfuehrung-in-R/chapters/04-tidyverse.html#fehlende-werte-auschliessen-drop_na)

F√ºhre die folgenden Schritte durch:

1.  **Datensatz downloaden und einlesen**\
    Lade den √úbungsdatensatz in R ein. Achte auf den Delimiter/das Trennzeichen (`;`)

```{r, echo = FALSE, results = 'hide', message= FALSE}

bfi_10_data <- read_delim("raw/bfi_10_data.csv", delim = ";", escape_double = FALSE, trim_ws = TRUE)
```

1.  **Fehlende Werte pr√ºfen**\
    Teste mit `is.na()`, ob der Datensatz fehlende Werte enth√§lt,\
    und z√§hle sie mit `table(is.na())`. Eine weitere Art und Weise einen √úberblick √ºber missings zu erhalten ist mit dem `skimr` Paket und der `skim()` Funktion. Teste diese.

```{r, echo = FALSE, results = 'hide'}

is.na(bfi_10_data)

table(is.na(bfi_10_data))

library(skimr)

skim(bfi_10_data)
```

1.  **Zeilen mit fehlenden Werten l√∂schen**\
    Erstelle eine **Kopie** des Datensatzes und verwende `drop_na()`,\
    um alle Zeilen mit fehlenden Werten zu entfernen.\
    Z√§hle anschlie√üend erneut, wie viele fehlende Werte noch vorhanden sind.

```{r, echo = FALSE, results = 'hide'}

clean_data_bfi_10 <- drop_na(bfi_10_data)
```

::: callout-caution
**Achtung:** Ein einziger fehlender Wert reicht aus, damit die **gesamte Zeile (also eine Versuchsperson)** entfernt wird!
:::

# Skalenberechnung

[üìñKapitel 4.4. Ellis & Mayer](https://methodenlehre.github.io/einfuehrung-in-R/chapters/04-tidyverse.html)

In den meisten psychologischen Studien arbeiten wir mit **Skalen**.\
Ein h√§ufig genutzter Fragebogen ist der **Big-Five-Fragebogen** mit 10 Items (BFI-10).\
In diesem Fragebogen sind einige **invertiert (reverse) kodierte Items** enthalten.

## **Umpolen der negativ formulierten Items**

-   Pole die negativ gepolten (reverse codierten) BFI-Items um. Die reverse kodierten Items enden immer mit `_r`. Du kannst daf√ºr **Base R** oder Funktionen aus dem **tidyverse** verwenden.

**Vervollst√§ndige diesen Code!**

-   N√∂tige Argumente: Datensatz, Variablen, Rekodierungsschema.

```{r eval= FALSE, echo=TRUE}

data_bfi_recoded <- XXXXX |> 
  mutate(
    across(
      c(XXXXXX),
      ~ case_when(
        . == 1 ~ 5,
        XXXXXXXXXX
      )
    )
  )


```

```{r, echo = FALSE, results = 'hide'}

data_bfi_recoded <- clean_data_bfi_10 |> 
  mutate(
    across(
      c(bfi_extra_1_r, bfi_agree_2_r, bfi_consc_2_r, bfi_neuro_2_r, bfi_open_2_r),
      ~ case_when(
        . == 1 ~ 5,
        . == 2 ~ 4,
        . == 3 ~ 3,
        . == 4 ~ 2,
        . == 5 ~ 1
      )
    )
  )

```

Erkl√§rungen zu diesem Code findest du hier: [Kapitel 4.4.6 Ellis & Mayer](https://methodenlehre.github.io/einfuehrung-in-R/chapters/04-tidyverse.html#neue-variablen-erstellen-mit-mutate) und hier: [Kapitel 4.4.7 Ellis & Mayer](https://methodenlehre.github.io/einfuehrung-in-R/chapters/04-tidyverse.html#variablen-rekodieren-mit-case_when)

## **Berechnung der Big-Five-Skalen**

-   Erstelle neue Variablen, die den **Mittelwert jedes Big-Five-Faktors** pro Person enthalten.

Nutze daf√ºr die Funktionen:

-   `mutate()`, `row_means()` und `select()`

üí°**Tipp:** Wenn du die `select()`-Funktion **innerhalb von `mutate()`** verwendest und den **native pipe (`|>`)** nutzt, musst du angeben, **auf welchen Datensatz** sich `select()` bezieht.

z.B: `extraversion = rowMeans(select(data_bfi_recoded, bfi_extra_1_r, bfi_extra_2))`

```{r, echo = FALSE, results = 'hide', eval=FALSE}


final_bfi <- data_bfi_recoded |>
  mutate(
    extraversion = rowMeans(select(data_bfi_recoded, bfi_extra_1_r, bfi_extra_2)),
    agreeableness = rowMeans(select(data_bfi_recoded, bfi_agree_1, bfi_agree_2_r)),
    conscientiousness = rowMeans(select(data_bfi_recoded, bfi_consc_1, bfi_consc_2_r)),
    neuroticism = rowMeans(select(data_bfi_recoded, bfi_neuro_1, bfi_neuro_2_r)),
    openness = rowMeans(select(data_bfi_recoded, bfi_open_1, bfi_open_2_r))
  )


```

**Abschluss√ºbung:** Versuche dein Skript dieser Hands on Einheit zu rendern. Wenn es nicht funktioniert, versuche die Fehlermeldungen nachzuvollziehen und zu beheben!

# Am Ende deiner √úbungen - vergiss nicht dein Skript abzuspeichern! üòâ
