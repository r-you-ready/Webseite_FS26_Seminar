---
title: "Haus√ºbung 1 L√∂sung"
editor: visual
draft: true
---

```{r, echo = FALSE, results = 'hide', message= FALSE}

library(tidyverse)
library(readxl)
library(skimr)
library(here)
```

```{r}
#| label: download-data
#| echo: false
#| message: false
#| warning: false
#| results: "hide"

# Copy from raw/ into the same folder as your .qmd (ryouready/)
file.copy(
  from = "raw/fake_bfi_dataset.csv",
  to   = "fake_bfi_dataset.csv",
  overwrite = TRUE
)


```

# Aufgabe 1: Datensatz aufbereiten und beschreiben

Wir arbeiten f√ºr die √úbungen mit diesem Datensatz. Dieser wurde simuliert und spiegelt keine echten Daten oder Zusammenh√§nge wider. Der Datensatz beinhaltet demografische Variablen sowie eine Version des BFI-44-Fragebogens. In den folgenden Aufgaben werden wir diesen mit den bisher kennengelernten **tidyverse**-Funktionen aufbereiten und analysieren.

<a href="fake_bfi_dataset.csv" download class="btn btn-primary"> üì• Download fake_bfi_dataset.csv </a>

Nutze die **dplyr**-Funktionen, die wir kennengelernt haben, um die folgenden Aufgaben zu bearbeiten.

**Tipp:** In einigen Variablen gibt es fehlende Werte (*missings*). Die Bearbeitung dieser Werte erfolgt erst in **Aufgabe 2**. Verwende, falls n√∂tig, das Argument `na.rm = TRUE`.

**Aufgaben**

-   Benenne die Variable *Ort* in *Postleitzahl* um.

::: {.callout-note collapse="true" title="L√∂sungen"}
```{r, message=FALSE}


data <- read_delim("raw/fake_bfi_dataset.csv", delim = ";", escape_double = FALSE, trim_ws = TRUE)


data <- data |> 
  rename(Postleitzahl = Ort)
```
:::

-   Welche Spalte scheint doppelt vorhanden zu sein? L√∂sche sie aus dem Datensatz.

::: {.callout-note collapse="true" title="L√∂sungen"}
```{r}

data <- select(data, - Ort_2)
```
:::

-   Personen die nicht vollj√§hrig sind d√ºrfen nicht an der Studie teilnehmen und m√ºssen ausgeschlossen werden.

::: {.callout-note collapse="true" title="L√∂sungen"}
```{r}

data <- filter(data, Age >= 18)
```
:::

-   F√ºge dem Datensatz die Spalte *Alterskohorte* hinzu. Wenn eine Person √ºber 60 Jahre alt ist, gilt sie als *alt*, ansonsten als *jung*.

::: {.callout-note collapse="true" title="L√∂sungen"}
```{r}

data <- data |>
  mutate(Alterskohorte = ifelse(Age > 60, "alt", "jung"))

```
:::

-   Welche Variablen sollten Faktoren sein? Wandle sie in Faktoren um

::: {.callout-note collapse="true" title="L√∂sungen"}
```{r}
data$Gender <- as.factor(data$Gender)
data$Alterskohorte <- as.factor(data$Alterskohorte)

```
:::

-   Erstelle eine Kopie des Datensatzes nur mit den demographischen Variablen.

::: {.callout-note collapse="true" title="L√∂sungen"}
```{r}
data_demographic <- data |> 
  select(Age, Gender, Postleitzahl, Alterskohorte)

```
:::

**Verwende die dplyr-Funktionen, um die folgenden Fragen zu beantworten:**

-   Welchen Anteil am Gesamtsample hat jeder Ort bzw. jede Postleitzahl, und wie kann dieser als neue Spalte im Datensatz erg√§nzt werden?

::: {.callout-note collapse="true" title="L√∂sungen"}
```{r}

data <- data |>
  group_by(Postleitzahl) |>
  mutate(proportion = n() / nrow(data)) |>
  ungroup()

```
:::

-   In welchem Quartier leben proportional am meisten Personen, die sich als weiblich beschreiben?

::: {.callout-note collapse="true" title="L√∂sungen"}
```{r}

data_demographic |>
  group_by(Postleitzahl) |>
  summarise(
    n_female = sum(Gender == "female", na.rm = TRUE),
    n_total = n(),
    proportion_weiblich = n_female / n_total
  ) |>
  arrange(desc(proportion_weiblich))

```
:::

-   Wie hoch ist das durschnittliche Alter pro Quartier?

::: {.callout-note collapse="true" title="L√∂sungen"}
```{r}

data_demographic |>
  group_by(Postleitzahl) |> 
  summarize(durschnittsalter = mean(Age))

```
:::

-   Wie alt sind die j√ºngsten Personen getrennt nach Gender?

::: {.callout-note collapse="true" title="L√∂sungen"}
```{r}

data_demographic |>
  group_by(Gender) |> 
  summarize(min_age = min(Age))

```
:::

-   Erstelle eine Rangliste der Quartiere nach durchschnittlichem Alter (vom h√∂chsten zum niedrigsten).

::: {.callout-note collapse="true" title="L√∂sungen"}
```{r}

rangliste <- data_demographic |>
  group_by(Postleitzahl) |> 
  summarise(mean_age = mean(Age)) |> 
  arrange(desc(mean_age))

rangliste
```
:::

# Aufgabe 2: Fehlende Werte

[üìñKapitel 4.3.3 Ellis & Mayer](https://methodenlehre.github.io/einfuehrung-in-R/chapters/04-tidyverse.html#fehlende-werte-auschliessen-drop_na)

F√ºhre die folgenden Schritte durch:

-   Untersuche den Datensatz auf fehlende Werte. Wie viele fehlende Werte gibt es insgesamt, und in welchen Variablen treten sie auf

::: {.callout-note collapse="true" title="L√∂sungen"}
```{r, message = FALSE}

skim(data)

table(is.na(data))
```
:::

-   Einige **Personen** haben keine Angabe zu ihrer Geschlechtsidentit√§t gemacht. Ersetze diese **fehlenden Werte (NAs)** durch *"Keine Angabe"*. Nutze daf√ºr die Funktion `mutate()` und `replace_na().` Beachte: Gender wurde bereits als Faktor definiert, muss aber erneut zu einem Character transformiert werden.

::: {.callout-note collapse="true" title="L√∂sungen"}
```{r}

library(dplyr)
library(tidyr)

data <- data |>
  mutate(
    Gender = as.character(Gender),
    Gender = replace_na(Gender, "Keine Angabe")
  )

```
:::

-   **Zeilen mit fehlenden Werten l√∂schen**\
    Erstelle eine **Kopie** des Datensatzes und verwende `drop_na()`,\
    um alle Zeilen mit fehlenden Werten zu entfernen.

::: {.callout-note collapse="true" title="L√∂sungen"}
```{r}

data_drop_na <- drop_na(data) 
```
:::

# Aufgabe 3: Skalenberechnung

[üìñKapitel 4.4. Ellis & Mayer](https://methodenlehre.github.io/einfuehrung-in-R/chapters/04-tidyverse.html)

**Aufgaben:**

-   **Umwandlung der BFI-Items in numerische Werte.**

    -   ‚ÄûStimme gar nicht zu‚Äú ‚Üí **1**

    -   ‚ÄûStimme voll und ganz zu‚Äú ‚Üí **5**

Verwende daf√ºr eine Kombination aus `mutate()`, `across()` und `case_when()` oder `recode()`.

::: {.callout-note collapse="true" title="L√∂sungen"}
```{r}


data_numeric <- data_drop_na |>
  mutate(
    across(
      extra_1:neuro_9_r,   # selects all columns in that range
      ~ case_when(
        . == "Stimme gar nicht zu" ~ 1,
        . == "Stimme eher nicht zu" ~ 2,
        . == "Neutral" ~ 3,
        . == "Stimme eher zu" ~ 4,
        . == "Stimme voll und ganz zu" ~ 5
      )
    )
  )

# Alternative mit recode
data_numeric <- data_drop_na |>
  mutate(
    across(
      extra_1:neuro_9_r,
      ~ recode(
        .,
        "Stimme gar nicht zu" = 1,
        "Stimme eher nicht zu" = 2,
        "Neutral" = 3,
        "Stimme eher zu" = 4,
        "Stimme voll und ganz zu" = 5
      )
    )
  )

```
:::

-   **Umpolen der negativ formulierten Items**

Die negativ formulierten Items enden alle mit `_r` (f√ºr reverse). Poole diese Items um.

Suche dir eine dplyr Funktion, welche helfen kann alle Variablen auszuw√§hlen welche mit `_r` aufh√∂ren.

üí°***Tipp: √Ñhnlich wie starts_with***

::: {.callout-note collapse="true" title="L√∂sungen"}
```{r}

library(dplyr)

data_reversed <- data_numeric |>
  mutate(
    across(
      ends_with("_r"),
      ~ case_when(
        . == 1 ~ 5,
        . == 2 ~ 4,
        . == 3 ~ 3,
        . == 4 ~ 2,
        . == 5 ~ 1
      )
    )
  )




```

```{r, eval=FALSE}
#Oder Effizienter

data_reversed <- data_numeric |>
  mutate(
    across(ends_with("_r"), ~ 6 - .) #~ 6 - . --> F√ºr jede wert der col -6 
  )


```
:::

-   

-   **Berechnung der Big-Five-Skalen**

    -   Erstelle neue Variablen, die den **Mittelwert jedes Big-Five-Faktors** pro Person enthalten.
    -   Mit welcher Funktion kannst du dir ersparen alle Variablen auszuschreiben?

::: {.callout-note collapse="true" title="L√∂sungen"}
```{r}


# Berechnung der Mittelwerte ohne na.rm
data_bfi_scores <- data_reversed |>
  mutate(
    extraversion = rowMeans(select(data_reversed, starts_with("extra"))),
    agreeableness = rowMeans(select(data_reversed, starts_with("agree"))),
    conscientiousness = rowMeans(select(data_reversed, starts_with("consc"))),
    neuroticism = rowMeans(select(data_reversed, starts_with("neuro"))),
    openness = rowMeans(select(data_reversed, starts_with("open")))
  )


```
:::

-   **Zusammenh√§nge zwischen Skalen testen**

    -   Teste mit `cor.test()` die **Korrelation** zwischen zwei Big-Five-Faktoren,\
        zum Beispiel zwischen **Extraversion** und **Offenheit**.

::: {.callout-note collapse="true" title="L√∂sungen"}
```{r}


# Korrelation zwischen Extraversion und Offenheit testen
cor.test(
  data_bfi_scores$extraversion,
  data_bfi_scores$openness
)


```
:::

<!-- -->

-   Berechne die **Durchschnittswerte**, **Standardabweichungen** und **Mediane** der Big-Five-Faktoren Extraversion und Offenheit, unterteilt nach der **Geschlechtsangabe**.

::: {.callout-note collapse="true" title="L√∂sungen"}
```{r}

data_summary <- data_bfi_scores |>
  group_by(Gender) |>
  summarise(
    across(
      c(extraversion, openness),
      list(
        Mittelwert = mean,
        SD = sd,
        Median = median
      ),
      na.rm = TRUE
    )
  )

data_summary
```
:::
